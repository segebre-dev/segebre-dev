import PostMetadata from '@/components/post-metadata';
import CalloutBlock from '@/components/callout-block';
import { metainformation } from './metadata';
import styles from './styles.module.css';

# {metainformation.title}

<PostMetadata
  date={new Date(metainformation.date)}
  lengthInMinutes={metainformation.lengthInMinutes}
  className={styles.metadata}
/>

While I could delve into the technical details of JavaScript's single-threaded asynchronicity, I believe there is already [a highly informative and widely shared technical explanation available on the topic](https://www.youtube.com/watch?v=8aGhZQkoFbQ). Therefore, I will try to introduce the topic in a more accessible manner that anyone, regardless of technical knowledge, can understand.

## The Situation

JavaScript (JS) is a single-threaded language, which means that it operates like an individual doing a job, as opposed to a multi-threaded language which operates like a team doing a job. As a single thread, it cannot work on anything other than the current task.

Despite this limitation, we can achieve asynchronous behavior when working with JavaScript. For example, we can make multiple requests for information simultaneously without having to wait for each one to finish before making the subsequent request.

> JavaScript is a single-threaded language. So how is it asynchronous?

## The Analogy

<CalloutBlock>
â„¹ï¸

This post is targeted at how JavaScript runs in the browser, however, many of these concepts translate to other runtime environments (e.g. Node.js).

</CalloutBlock>

To simplify the different elements that take part in the analogy, I will gradually introduce them along the way. As I introduce the elements, I will leave callback blocks as quick references in case you need to refer back to something.

### The setup

Let's imagine we have a ğŸ›– restaurant with only one ğŸ§µwaitperson.

<CalloutBlock>
ğŸ›–

restaurant = Website

</CalloutBlock>

The ğŸ§µwaitperson is our interface to ask questions, get answers, and perform actions.

<CalloutBlock>
ğŸ§µ

waitperson = main JS thread

</CalloutBlock>

The ğŸ§µwaitperson can only attend to one ğŸ“order at a time. However, getting the client's order does NOT occur sequentially. Instead, everyoneâ€™s food goes through the same process of ordering, preparing, and serving at the â€œsame timeâ€. But there is only a single ğŸ§µwaitperson, so how do they manage it? ğŸ¤”

<CalloutBlock>
ğŸ“

order = JS command

</CalloutBlock>

### The flow

In this case, the ğŸ›–restaurant has more going on than the customers get to see. For example, it needs a âš™kitchen to work. The customer usually does not know what is happening inside the âš™kitchen, yet it handles much of the work required to deliver what they ordered. So, what is the flow here, and, once again, how does one ğŸ§µwaitperson manage to serve all the ğŸ“orders concurrently?

<CalloutBlock>
âš™

kitchen = Browser

</CalloutBlock>

Let's break it down:

1. A customer makes an ğŸ“order; during this time, the ğŸ§µwaitperson is blocked and cannot answer anyone else or do anything else during this time.
2. Once that is finished, the ğŸ§µwaitperson either immediately fulfills the request(e.g. the customer asks for a straw) or takes the ğŸ“order to the âš™kitchen.
3. The âš™kitchen prepares the ğŸ“order using ğŸ”ªkitchen utensils and tools.
4. Once the ğŸ“order is done, âš™the kitchen puts it on the ğŸ›ï¸counter.
5. Eventually, when the ğŸ§µwaitperson is free, the ğŸ§‘â€ğŸ³kitchen assistant (who is needed in this case to coordinate between the busy ğŸ§µwaitperson and âš™kitchen) picks up the order from the ğŸ›ï¸counter and gives it to the ğŸ§µwaitperson.
6. The ğŸ§µwaitperson then delivers it to the customers.

<CalloutBlock>
ğŸ”ª

kitchen utensils and tools = Web APIs

</CalloutBlock>

<CalloutBlock>
ğŸ§‘â€ğŸ³

kitchen assistant = The event loop

</CalloutBlock>

<CalloutBlock>
ğŸ›ï¸

counter = The task queue

</CalloutBlock>

## In conclusion

The beauty of this is that during steps 3 and 4, the ğŸ§µwaitperson is free and can do other things. So, the ğŸ§µwaitperson returns to other customers and gets more ğŸ“orders, and the process repeats.

Steps 1, 2, 5, and 6 can ONLY be done sequentially; in other words, the waiter cannot take two tables' ğŸ“orders simultaneously. However, steps 3 and 4 can happen in parallel, the âš™kitchen can and will cook as many ğŸ“orders as possible.

Interestingly enough, the ğŸ§µwaitperson steps tend to be quick, and the âš™kitchen steps tend to be slow. Still, the âš™kitchen has more than one person working on the orders, so everything works smoothly and seems to happen fully in parallel.

Note that it is critically important that you do not give long tasks to the ğŸ§µwaitperson; If you do, for example, ask the ğŸ§µwaitperson to cook, then they will be blocked in cooking while customers are waiting to place their ğŸ“orders. No one answers their calls and rings, making it seem like the ğŸ›–restaurant is frozen.

I guess now we know why websites that use JavaScript freeze sometimes. ğŸ¤“

I hope this analogy helps you. If it does, please reach out; I'd love to know about it! If it did not, or something is incorrect, let me know; I'm always happy to learn and improve.

Kudos/special thanks to [Sean](https://www.linkedin.com/in/seanowenhayes/) for bringing up the challenge, [Angelo](https://www.angelodias.com.br/) for encouraging my analogy to become a blog post, and [the foobar Agency team](https://foobar.agency/team), who supported me along the way with thorough reviews.
